{"version":3,"file":"82faba8da9409ec0c9c801a624ca743cb7a619f0-01b9ec51eb87090e1cee.js","mappings":"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","sources":["webpack://jazevedo.me/./node_modules/fast-deep-equal/index.js","webpack://jazevedo.me/./src/components/WaveCanvas/log.ts","webpack://jazevedo.me/./src/components/WaveCanvas/WaveRenderer.ts","webpack://jazevedo.me/./src/components/WaveCanvas/OrthoViewport.ts","webpack://jazevedo.me/./src/components/WaveCanvas/shaders/blend/default.glsl","webpack://jazevedo.me/./src/components/WaveCanvas/shaders/noise/default.glsl","webpack://jazevedo.me/./src/components/WaveCanvas/WaveCanvas.tsx","webpack://jazevedo.me/./src/components/WaveCanvas/index.ts","webpack://jazevedo.me/./src/components/WaveCanvas/shaders/index.ts","webpack://jazevedo.me/./src/components/WaveCanvas/shaders/main.frag"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","function doesWindowConsoleExist(): boolean {\n  return (\n    typeof window !== \"undefined\" &&\n    typeof window.console !== \"undefined\" &&\n    window.console != null\n  );\n}\n\nexport function log(subsystem: string, message: string): void {\n  if (doesWindowConsoleExist()) {\n    window.console.log(`[${subsystem}] ${message}`);\n  }\n}\n\nexport function logWarn(subsystem: string, message: string): void {\n  if (doesWindowConsoleExist()) {\n    window.console.warn(`[${subsystem}] ${message}`);\n  }\n}\n\nexport function logError(subsystem: string, message: string): void {\n  if (doesWindowConsoleExist()) {\n    window.console.error(`[${subsystem}] ${message}`);\n  }\n}\n","/* eslint-disable max-classes-per-file */\n\nimport type { RgbColor } from \"polished/lib/types/color\";\nimport {\n  OrthographicCamera,\n  WebGLRenderer,\n  Scene,\n  Mesh,\n  PlaneGeometry,\n  ShaderMaterial,\n  Color as ThreeColor,\n  Vector2,\n  IUniform,\n} from \"three\";\n\nimport { logError, logWarn } from \"./log\";\nimport type { NonEmptyArray } from \"../../ts-utils\";\nimport {\n  createOrthoCamera,\n  adaptiveZoomOrthoViewport,\n  updateOrthoCamera,\n} from \"./OrthoViewport\";\nimport type { OrthoViewport } from \"./OrthoViewport\";\nimport { MAX_LIGHTS, makeVertexShader, makeFragmentShader } from \"./shaders\";\nimport type { LightStruct } from \"./shaders\";\nimport defaultNoise from \"./shaders/noise/default.glsl\";\nimport defaultBlend from \"./shaders/blend/default.glsl\";\n\n// The aspect ratio is designed to create a square area ((-1,-1) to (1,1)) that\n// will always have the deformed, tilted plane covering it. The adaptive zoom\n// camera then ensures that the canvas viewport is some region of this square\n// area.\nconst PLANE_ASPECT: Vector2 = new Vector2(1, 3.2);\nconst PLANE_SCALE: Vector2 = new Vector2(2, 2);\nconst PLANE_TILT = 0.75;\nconst CAMERA_BASE_VIEWPORT: OrthoViewport = {\n  left: -1,\n  right: 1,\n  top: 1,\n  bottom: -1,\n  near: -100,\n  far: 100,\n};\nfunction computeCameraViewport(\n  clientWidth: number,\n  clientHeight: number\n): OrthoViewport {\n  return adaptiveZoomOrthoViewport({\n    clientWidth,\n    clientHeight,\n    baseViewport: CAMERA_BASE_VIEWPORT,\n  });\n}\n\ntype PlaybackState =\n  | {\n      type: \"playing\";\n      startTimestamp: DOMHighResTimeStamp;\n      frameCount: number;\n    }\n  | {\n      type: \"paused\";\n      pauseTime: number;\n      forceRerenderNextFrame: boolean;\n    };\n\ntype RendererState =\n  | {\n      type: \"unmounted\";\n    }\n  | {\n      type: \"mounted\";\n      canvas: HTMLCanvasElement;\n      boundOnResizeWindow: () => void;\n      camera: OrthographicCamera;\n      renderer: WebGLRenderer;\n      scene: Scene;\n      plane: Mesh;\n      material: ShaderMaterial;\n      frameCount: number;\n      playbackState: PlaybackState;\n      renderStopWrapper: RenderStopWrapper;\n    };\n\nexport type Vector2Like = readonly [x: number, y: number] | number;\n\n/**\n * A renderer for the waves in the hero background.\n *\n * This can be mounted onto a canvas HTML element, and will handle rendering\n * the waves to the canvas every other frame.\n */\nexport default class WaveRenderer {\n  public static DEFAULT_WAVE_COLOR: RgbColor = {\n    red: 0,\n    green: 0,\n    blue: 0,\n  };\n\n  public static DEFAULT_INITIAL_TIME = 0;\n  public static DEFAULT_SUBDIVISION: Vector2Like = 64;\n  public static DEFAULT_BLEND_SOURCE = defaultBlend;\n  public static DEFAULT_NOISE_SOURCE = defaultNoise;\n\n  public static DEFAULT_DEFORM_NOISE_FREQUENCY: Vector2Like = 2;\n  public static DEFAULT_DEFORM_NOISE_SPEED = 6;\n  public static DEFAULT_DEFORM_NOISE_STRENGTH = 2;\n  public static DEFAULT_DEFORM_NOISE_SCROLL_SPEED: Vector2Like = [2.5, 1];\n  public static DEFAULT_DEFORM_NOISE_CLAMP_LOW = -1;\n  public static DEFAULT_DEFORM_NOISE_CLAMP_HIGH = 1;\n\n  public static DEFAULT_LIGHT_NOISE_FREQUENCY: Vector2Like = 1;\n  public static DEFAULT_LIGHT_NOISE_SPEED = 3;\n  public static DEFAULT_LIGHT_NOISE_SCROLL_SPEED: Vector2Like = [2.5, 1];\n  public static DEFAULT_LIGHT_NOISE_CLAMP_LOW = -0.5;\n  public static DEFAULT_LIGHT_NOISE_CLAMP_HIGH = 1;\n  public static DEFAULT_LIGHT_BLEND_STRENGTH = 1;\n  public static DEFAULT_PER_LIGHT_NOISE_OFFSET = 8;\n\n  private onLoadCallback: (() => void) | null = null;\n  private onRenderCallback: (() => void) | null = null;\n  private colors: NonEmptyArray<RgbColor> = [WaveRenderer.DEFAULT_WAVE_COLOR];\n  private fallbackColor: RgbColor = WaveRenderer.DEFAULT_WAVE_COLOR;\n  private timeOffset: number = WaveRenderer.DEFAULT_INITIAL_TIME;\n  private subdivision: Vector2Like = WaveRenderer.DEFAULT_SUBDIVISION;\n  private startPaused = false;\n  private startAtTime: number | null = null;\n  private blendSource: string = WaveRenderer.DEFAULT_BLEND_SOURCE;\n  private noiseSource: string = WaveRenderer.DEFAULT_NOISE_SOURCE;\n  private extraUniforms: Record<string, IUniform> = {};\n\n  private deformNoiseFrequency: Vector2Like =\n    WaveRenderer.DEFAULT_DEFORM_NOISE_FREQUENCY;\n  private deformNoiseSpeed: number = WaveRenderer.DEFAULT_DEFORM_NOISE_SPEED;\n  private deformNoiseStrength: number =\n    WaveRenderer.DEFAULT_DEFORM_NOISE_STRENGTH;\n  private deformNoiseScrollSpeed: Vector2Like =\n    WaveRenderer.DEFAULT_DEFORM_NOISE_SCROLL_SPEED;\n  private deformNoiseClampLow: number =\n    WaveRenderer.DEFAULT_DEFORM_NOISE_CLAMP_LOW;\n  private deformNoiseClampHigh: number =\n    WaveRenderer.DEFAULT_DEFORM_NOISE_CLAMP_HIGH;\n\n  private lightNoiseFrequency: Vector2Like =\n    WaveRenderer.DEFAULT_LIGHT_NOISE_FREQUENCY;\n  private lightNoiseSpeed: number = WaveRenderer.DEFAULT_LIGHT_NOISE_SPEED;\n  private lightNoiseScrollSpeed: Vector2Like =\n    WaveRenderer.DEFAULT_LIGHT_NOISE_SCROLL_SPEED;\n  private lightNoiseClampLow: number =\n    WaveRenderer.DEFAULT_LIGHT_NOISE_CLAMP_LOW;\n  private lightNoiseClampHigh: number =\n    WaveRenderer.DEFAULT_LIGHT_NOISE_CLAMP_HIGH;\n  private lightBlendStrength: number =\n    WaveRenderer.DEFAULT_LIGHT_BLEND_STRENGTH;\n  private perLightNoiseOffset: number =\n    WaveRenderer.DEFAULT_PER_LIGHT_NOISE_OFFSET;\n\n  private state: RendererState = { type: \"unmounted\" };\n\n  /**\n   * Sets the callback to invoke when the renderer has finished loading.\n   *\n   * This is called at the end of the `mount` method.\n   */\n  public setOnLoad(callback: (() => void) | null): void {\n    this.onLoadCallback = callback;\n  }\n\n  /**\n   * Sets the callback to invoke at the end of each frame.\n   */\n  public setOnRender(callback: (() => void) | null): void {\n    this.onRenderCallback = callback;\n  }\n\n  /**\n   * Sets the colors to use for the waves. The array must be non-empty.\n   */\n  public setColors(colors: Readonly<NonEmptyArray<RgbColor>>): void {\n    let colorsCopy = colors.slice() as NonEmptyArray<RgbColor>;\n    if (colorsCopy.length > MAX_LIGHTS) {\n      logWarn(\n        \"WaveRenderer\",\n        `Too many colors provided (${colorsCopy.length}). Only the first ${MAX_LIGHTS} will be used.`\n      );\n      colorsCopy = colorsCopy.slice(0, MAX_LIGHTS) as NonEmptyArray<RgbColor>;\n    }\n\n    this.colors = colorsCopy;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLights.value =\n        this.getLightsUniformValue();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the color that will be used as the \"clear color\" for the canvas\n   * renderer. If the renderer has already mounted, then this will cause the\n   * renderer to update the material.\n   */\n  public setFallbackColor(color: RgbColor | null): void {\n    this.fallbackColor = color ?? WaveRenderer.DEFAULT_WAVE_COLOR;\n\n    if (this.state.type === \"mounted\") {\n      this.state.renderer.setClearColor(\n        rgbColorToThreeColor(this.fallbackColor)\n      );\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the initial time for the wave animation. This can be used to control\n   * the initial frame so that it is reproducible.\n   */\n  public setTimeOffset(time: number | null): void {\n    this.timeOffset = time ?? WaveRenderer.DEFAULT_INITIAL_TIME;\n    this.invalidateIfPaused();\n  }\n\n  /**\n   * Sets the subdivision of the plane geometry. This is a vector so that the\n   * plane can be subdivided differently in the x and y directions.\n   *\n   * Note that the vector passed in is implicitly scaled by the plane's aspect\n   * ratio, which might not be square.\n   */\n  public setSubdivision(subdivision: Vector2Like | null): void {\n    this.subdivision = subdivision ?? WaveRenderer.DEFAULT_SUBDIVISION;\n\n    if (this.state.type === \"mounted\") {\n      this.state.plane.geometry.dispose();\n      this.state.plane.geometry = this.createPlaneGeometry();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets whether the animation is paused.\n   */\n  public setIsPaused(isPaused: boolean | null): void {\n    this.startPaused = isPaused ?? false;\n\n    if (this.state.type === \"mounted\") {\n      if (this.state.playbackState.type === \"paused\" && !isPaused) {\n        const newStartTimestamp = performance.now();\n        this.state.playbackState = {\n          type: \"playing\",\n          startTimestamp:\n            newStartTimestamp - this.state.playbackState.pauseTime * 1000,\n          frameCount: 1,\n        };\n      } else if (this.state.playbackState.type === \"playing\" && isPaused) {\n        const now = performance.now();\n        this.state.playbackState = {\n          type: \"paused\",\n          pauseTime: (now - this.state.playbackState.startTimestamp) / 1000,\n          forceRerenderNextFrame: true,\n        };\n      }\n    }\n  }\n\n  /**\n   * Sets a custom noise function for the wave deformation and colors. This is a\n   * GLSL snippet that should contain an implementation for the following\n   * interface:\n   *\n   * ```glsl\n   * float noiseFunc(vec3 v);\n   * ```\n   */\n  public setNoiseSource(noiseSource: string | null): void {\n    this.noiseSource = noiseSource ?? WaveRenderer.DEFAULT_NOISE_SOURCE;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.vertexShader = makeVertexShader({\n        noiseSource: this.noiseSource,\n        blendSource: this.blendSource,\n      });\n      this.state.material.needsUpdate = true;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets a custom blend function for the light colors. This is a GLSL snippet\n   * that should contain an implementation for the following interface:\n   *\n   * ```glsl\n   * vec3 blendFunc(vec3 bg, vec3 fg, float alpha);\n   * ```\n   */\n  public setBlendSource(blendSource: string | null): void {\n    this.blendSource = blendSource ?? WaveRenderer.DEFAULT_BLEND_SOURCE;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.vertexShader = makeVertexShader({\n        noiseSource: this.noiseSource,\n        blendSource: this.blendSource,\n      });\n      this.state.material.needsUpdate = true;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets custom uniforms for the wave shaders.\n   */\n  public setExtraUniforms(newUniforms: Record<string, IUniform> | null): void {\n    const uniformKeysBefore = new Set(Object.keys(this.extraUniforms));\n    this.extraUniforms = newUniforms ?? {};\n\n    if (this.state.type === \"mounted\") {\n      const uniformKeysAfter = new Set(Object.keys(this.extraUniforms));\n      // From https://stackoverflow.com/a/31129384:\n      const setEquality = <T>(xs: Set<T>, ys: Set<T>): boolean =>\n        xs.size === ys.size && [...xs].every((x) => ys.has(x));\n      if (setEquality(uniformKeysBefore, uniformKeysAfter)) {\n        // If the uniforms are the same, then we can just update the values.\n        const { material } = this.state;\n        Object.entries(this.extraUniforms).forEach(([key, value]) => {\n          (material.uniforms[key] as IUniform<unknown>).value = value.value;\n        });\n      } else {\n        // Otherwise, we need to recreate the material.\n        Object.assign(this.state.material.uniforms, this.extraUniforms);\n        this.state.material.needsUpdate = true;\n      }\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the frequency of the deform noise texture. Higher values increase the\n   * number of peaks and valleys that appear on the plane, and decrease their\n   * x-y size. This is a vector so that the noise can be scaled differently in\n   * the x and y directions.\n   */\n  public setDeformNoiseFrequency(frequency: Vector2Like | null): void {\n    this.deformNoiseFrequency =\n      frequency ?? WaveRenderer.DEFAULT_DEFORM_NOISE_FREQUENCY;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseFrequency.value =\n        this.getDeformNoiseFrequency();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the speed of the animation of the deform noise texture. Higher values\n   * result in faster animation.\n   */\n  public setDeformNoiseSpeed(speed: number | null): void {\n    this.deformNoiseSpeed = speed ?? WaveRenderer.DEFAULT_DEFORM_NOISE_SPEED;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseSpeed.value =\n        this.getDeformNoiseSpeed();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the strength of the deform noise texture. Higher values result in\n   * sharper valleys and peaks.\n   */\n  public setDeformNoiseStrength(strength: number | null): void {\n    this.deformNoiseStrength =\n      strength ?? WaveRenderer.DEFAULT_DEFORM_NOISE_STRENGTH;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseStrength.value =\n        this.getDeformNoiseStrength();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the speed of the passive scrolling of the deform noise texture. Higher\n   * values result in faster scrolling. This is a vector so that the noise can\n   * be scrolled at different speeds in the x and y directions.\n   */\n  public setDeformNoiseScrollSpeed(scrollSpeed: Vector2Like | null): void {\n    this.deformNoiseScrollSpeed =\n      scrollSpeed ?? WaveRenderer.DEFAULT_DEFORM_NOISE_SCROLL_SPEED;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseScrollSpeed.value =\n        this.getDeformNoiseScrollSpeed();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the minimum value of the deform noise texture.\n   */\n  public setDeformNoiseClampLow(clampLow: number | null): void {\n    this.deformNoiseClampLow =\n      clampLow ?? WaveRenderer.DEFAULT_DEFORM_NOISE_CLAMP_LOW;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseClampLow.value =\n        this.deformNoiseClampLow;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the maximum value of the deform noise texture.\n   */\n  public setDeformNoiseClampHigh(clampHigh: number | null): void {\n    this.deformNoiseClampHigh =\n      clampHigh ?? WaveRenderer.DEFAULT_DEFORM_NOISE_CLAMP_HIGH;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inDeformNoiseClampHigh.value =\n        this.deformNoiseClampHigh;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the frequency of the light noise texture. Higher values increase the\n   * number of bright areas that appear on the plane and decrease their size.\n   * This is a vector so that the noise can be scaled differently in the x and\n   * y directions.\n   */\n  public setLightNoiseFrequency(frequency: Vector2Like | null): void {\n    this.lightNoiseFrequency =\n      frequency ?? WaveRenderer.DEFAULT_LIGHT_NOISE_FREQUENCY;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightNoiseFrequency.value =\n        this.getLightNoiseFrequency();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the speed of the animation of the light noise texture. Higher values\n   * result in faster animation.\n   */\n  public setLightNoiseSpeed(speed: number | null): void {\n    this.lightNoiseSpeed = speed ?? WaveRenderer.DEFAULT_LIGHT_NOISE_SPEED;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightNoiseSpeed.value =\n        this.getLightNoiseSpeed();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the speed of the passive scrolling of the light noise texture. Higher\n   * values result in faster scrolling. This is a vector so that the noise can\n   * be scrolled at different speeds in the x and y directions.\n   */\n  public setLightNoiseScrollSpeed(scrollSpeed: Vector2Like | null): void {\n    this.lightNoiseScrollSpeed =\n      scrollSpeed ?? WaveRenderer.DEFAULT_LIGHT_NOISE_SCROLL_SPEED;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightNoiseScrollSpeed.value =\n        this.getLightNoiseScrollSpeed();\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the minimum value of the light noise texture.\n   */\n  public setLightNoiseClampLow(clampLow: number | null): void {\n    this.lightNoiseClampLow =\n      clampLow ?? WaveRenderer.DEFAULT_LIGHT_NOISE_CLAMP_LOW;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightNoiseClampLow.value =\n        this.lightNoiseClampLow;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the maximum value of the light noise texture.\n   */\n  public setLightNoiseClampHigh(clampHigh: number | null): void {\n    this.lightNoiseClampHigh =\n      clampHigh ?? WaveRenderer.DEFAULT_LIGHT_NOISE_CLAMP_HIGH;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightNoiseClampHigh.value =\n        this.lightNoiseClampHigh;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the opacity that each light will have when blended together. The last\n   * light will inherently be the strongest, since it is applied last (using a\n   * \"normal\" blend mode).\n   */\n  public setLightBlendStrength(strength: number | null): void {\n    this.lightBlendStrength =\n      strength ?? WaveRenderer.DEFAULT_LIGHT_BLEND_STRENGTH;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inLightBlendStrength.value =\n        this.lightBlendStrength;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Sets the offset that each successive light will have on the noise texture.\n   */\n  public setPerLightNoiseOffset(offset: number | null): void {\n    this.perLightNoiseOffset =\n      offset ?? WaveRenderer.DEFAULT_PER_LIGHT_NOISE_OFFSET;\n\n    if (this.state.type === \"mounted\") {\n      this.state.material.uniforms.inPerLightNoiseOffset.value =\n        this.perLightNoiseOffset;\n      this.invalidateIfPaused();\n    }\n  }\n\n  /**\n   * Mounts the renderer to the given canvas, initializing the mesh geometry\n   * and compiling the shaders.\n   */\n  public mount({ canvas }: { canvas: HTMLCanvasElement }): void {\n    const scene = new Scene();\n    const { clientWidth, clientHeight } = canvas;\n    const initialViewport = computeCameraViewport(clientWidth, clientHeight);\n    const camera = createOrthoCamera(initialViewport);\n    camera.name = \"main-camera\";\n    scene.add(camera);\n\n    const renderer = new WebGLRenderer({ canvas, antialias: true });\n    renderer.setSize(clientWidth, clientHeight, /* updateStyle */ false);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setClearColor(rgbColorToThreeColor(this.fallbackColor));\n\n    const { plane, material } = this.setupScene({\n      scene,\n    });\n\n    const boundOnResizeWindow = this.onResizeWindow.bind(this);\n    window.addEventListener(\"resize\", boundOnResizeWindow);\n\n    let playbackState: PlaybackState;\n    if (this.startPaused) {\n      playbackState = {\n        type: \"paused\",\n        pauseTime: this.startAtTime ?? 0,\n        forceRerenderNextFrame: true,\n      };\n    } else {\n      const startTimestamp = performance.now();\n      playbackState = {\n        type: \"playing\",\n        startTimestamp: startTimestamp - (this.startAtTime ?? 0) * 1000,\n        frameCount: 1,\n      };\n    }\n\n    const renderStopWrapper = new RenderStopWrapper(this.render.bind(this));\n    this.state = {\n      type: \"mounted\",\n      canvas,\n      boundOnResizeWindow,\n      camera,\n      renderer,\n      scene,\n      plane,\n      material,\n      playbackState,\n      frameCount: 1,\n      renderStopWrapper,\n    };\n\n    if (this.onLoadCallback != null) {\n      this.onLoadCallback();\n    }\n\n    renderStopWrapper.start();\n  }\n\n  /**\n   * Tears down the renderer and frees up resources. The state of the renderer\n   * afterwards will be its initial state, and can be mounted again.\n   */\n  public unmount(): void {\n    if (this.state.type === \"unmounted\") {\n      logError(\"WaveRenderer\", \"Cannot unmount when already unmounted\");\n      return;\n    }\n\n    window.removeEventListener(\"resize\", this.state.boundOnResizeWindow);\n    this.state.material.dispose();\n    this.state.renderer.dispose();\n    this.state.renderStopWrapper.stop();\n    this.state = { type: \"unmounted\" };\n  }\n\n  /**\n   * Restarts the animation to `t = this.timeOffset`.\n   */\n  public restartAnimation(): void {\n    if (this.state.type === \"unmounted\") {\n      logError(\"WaveRenderer\", \"Cannot restart animation when unmounted\");\n      return;\n    }\n\n    if (this.state.playbackState.type === \"playing\") {\n      const startTimestamp = performance.now();\n      this.state.playbackState = {\n        type: \"playing\",\n        startTimestamp,\n        frameCount: 1,\n      };\n    } else {\n      this.state.playbackState = {\n        type: \"paused\",\n        pauseTime: 0,\n        forceRerenderNextFrame: true,\n      };\n    }\n  }\n\n  public exportImage(mimeType: string): string {\n    if (this.state.type === \"unmounted\") {\n      logError(\"WaveRenderer\", \"Cannot export image when unmounted\");\n      return \"\";\n    }\n\n    // Re-render the scene to ensure that the pixel data is in the buffer.\n    this.state.material.uniforms.inTime.value =\n      this.getTime() + this.timeOffset;\n    this.state.renderer.render(this.state.scene, this.state.camera);\n    const dataUrl = this.state.canvas.toDataURL(mimeType);\n    return dataUrl;\n  }\n\n  private createMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        inTime: { value: /* This value is ignored */ 0 },\n        inDeformNoiseFrequency: { value: this.getDeformNoiseFrequency() },\n        inDeformNoiseSpeed: { value: this.getDeformNoiseSpeed() },\n        inDeformNoiseStrength: { value: this.getDeformNoiseStrength() },\n        inDeformNoiseScrollSpeed: { value: this.getDeformNoiseScrollSpeed() },\n        inDeformNoiseClampLow: { value: this.deformNoiseClampLow },\n        inDeformNoiseClampHigh: { value: this.deformNoiseClampHigh },\n        inLights: { value: this.getLightsUniformValue() },\n        inLightNoiseFrequency: { value: this.getLightNoiseFrequency() },\n        inLightNoiseSpeed: { value: this.getLightNoiseSpeed() },\n        inLightNoiseScrollSpeed: { value: this.getLightNoiseScrollSpeed() },\n        inLightNoiseClampLow: { value: this.lightNoiseClampLow },\n        inLightNoiseClampHigh: { value: this.lightNoiseClampHigh },\n        inLightBlendStrength: { value: this.lightBlendStrength },\n        inPerLightNoiseOffset: { value: this.perLightNoiseOffset },\n        ...this.extraUniforms,\n      },\n      vertexShader: makeVertexShader({\n        noiseSource: this.noiseSource,\n        blendSource: this.blendSource,\n      }),\n      fragmentShader: makeFragmentShader(),\n    });\n  }\n\n  private setupScene({ scene }: { scene: Scene }): {\n    plane: Mesh;\n    material: ShaderMaterial;\n  } {\n    const geometry = this.createPlaneGeometry();\n    const material = this.createMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.rotation.x = (Math.PI / 2) * PLANE_TILT;\n    scene.add(plane);\n\n    return { plane, material };\n  }\n\n  private createPlaneGeometry(): PlaneGeometry {\n    const size: Vector2 = new Vector2(\n      PLANE_ASPECT.x * PLANE_SCALE.x,\n      PLANE_ASPECT.y * PLANE_SCALE.x\n    );\n    const baseSubdivisions = vector2LikeToThreeVector2(this.subdivision);\n    const subdivisions = new Vector2(\n      Math.ceil(baseSubdivisions.x * PLANE_ASPECT.x),\n      Math.ceil(baseSubdivisions.y * PLANE_ASPECT.y)\n    );\n    return new PlaneGeometry(size.x, size.y, subdivisions.x, subdivisions.y);\n  }\n\n  private getLightsUniformValue(): LightStruct {\n    return {\n      count: this.colors.length,\n      // Pad the array with black to the max number of lights\n      colors: this.colors\n        .map<ThreeColor>(rgbColorToThreeColor)\n        .concat(\n          new Array(MAX_LIGHTS - this.colors.length).fill(\n            rgbColorToThreeColor({ red: 0, green: 0, blue: 0 })\n          )\n        ),\n    };\n  }\n\n  private getDeformNoiseFrequency(): Vector2 {\n    const vec = vector2LikeToThreeVector2(this.deformNoiseFrequency);\n    return new Vector2(vec.x * PLANE_ASPECT.x, vec.y * PLANE_ASPECT.y);\n  }\n\n  private getDeformNoiseSpeed(): number {\n    // Implicitly scale by 100 to make default value more reasonable:\n    return this.deformNoiseSpeed / 100;\n  }\n\n  private getDeformNoiseStrength(): number {\n    // Implicitly scale by 10 to make default value more reasonable:\n    return this.deformNoiseStrength / 10;\n  }\n\n  private getDeformNoiseScrollSpeed(): Vector2 {\n    // Implicitly scale by 100 to make default value more reasonable:\n    const vec = vector2LikeToThreeVector2(\n      this.deformNoiseScrollSpeed\n    ).multiplyScalar(1 / 100);\n    return new Vector2(vec.x * PLANE_ASPECT.x, vec.y * PLANE_ASPECT.y);\n  }\n\n  private getLightNoiseFrequency(): Vector2 {\n    const vec = vector2LikeToThreeVector2(this.lightNoiseFrequency);\n    return new Vector2(vec.x * PLANE_ASPECT.x, vec.y * PLANE_ASPECT.y);\n  }\n\n  private getLightNoiseSpeed(): number {\n    // Implicitly scale by 100 to make default value more reasonable:\n    return this.lightNoiseSpeed / 100;\n  }\n\n  private getLightNoiseScrollSpeed(): Vector2 {\n    // Implicitly scale by 100 to make default value more reasonable:\n    const vec = vector2LikeToThreeVector2(\n      this.lightNoiseScrollSpeed\n    ).multiplyScalar(1 / 100);\n    return new Vector2(vec.x * PLANE_ASPECT.x, vec.y * PLANE_ASPECT.y);\n  }\n\n  /**\n   * Called from `requestAnimationFrame` to render the scene.\n   */\n  private render(timestamp: DOMHighResTimeStamp): void {\n    if (this.state.type === \"unmounted\") {\n      return;\n    }\n\n    const { playbackState } = this.state;\n    const time = this.getTime(timestamp);\n    if (time === null) {\n      throw new Error(\"Time should not be null\");\n    }\n    if (playbackState.type === \"paused\") {\n      if (playbackState.forceRerenderNextFrame) {\n        playbackState.forceRerenderNextFrame = false;\n\n        this.state.material.uniforms.inTime.value = time + this.timeOffset;\n        this.state.renderer.render(this.state.scene, this.state.camera);\n        if (this.onRenderCallback !== null) {\n          this.onRenderCallback();\n        }\n      }\n    } else if (playbackState.type === \"playing\") {\n      if (playbackState.frameCount % 2 !== 1) {\n        // Skip this frame to reduce load.\n      } else {\n        this.state.material.uniforms.inTime.value = time + this.timeOffset;\n        this.state.renderer.render(this.state.scene, this.state.camera);\n        if (this.onRenderCallback !== null) {\n          this.onRenderCallback();\n        }\n      }\n\n      playbackState.frameCount += 1;\n    }\n  }\n\n  /**\n   * Returns the second offset of the animation, relative to the initial time.\n   */\n  public getTime(atTimestamp?: DOMHighResTimeStamp): number {\n    if (this.state.type === \"unmounted\") {\n      return this.startAtTime ?? 0;\n    }\n\n    const { playbackState } = this.state;\n    if (playbackState.type === \"paused\") {\n      return playbackState.pauseTime;\n    } else if (playbackState.type === \"playing\") {\n      const resolvedTimestamp = atTimestamp ?? performance.now();\n      const elapsed = resolvedTimestamp - playbackState.startTimestamp;\n      return elapsed / 1000;\n    } else {\n      throw new Error(\"Unexpected playback state\");\n    }\n  }\n\n  /**\n   * Seeks to a specific time in the animation, relative to the initial time.\n   */\n  public seekToTime(time: number): void {\n    if (this.state.type === \"unmounted\") {\n      this.startAtTime = time;\n      return;\n    }\n\n    const { playbackState } = this.state;\n    if (playbackState.type === \"playing\") {\n      playbackState.startTimestamp = performance.now() - time * 1000;\n    } else if (playbackState.type === \"paused\") {\n      playbackState.pauseTime = time;\n    }\n  }\n\n  /**\n   * Forces a re-render of the scene if the playback state is paused.\n   */\n  private invalidateIfPaused(): void {\n    if (this.state.type === \"unmounted\") {\n      return;\n    }\n\n    const { playbackState } = this.state;\n    if (playbackState.type === \"paused\") {\n      playbackState.forceRerenderNextFrame = true;\n    }\n  }\n\n  /**\n   * Callback that gets bound to the window's `resize` event.\n   */\n  private onResizeWindow(): void {\n    if (this.state.type === \"unmounted\") {\n      logWarn(\"WaveRenderer\", \"Cannot resize when unmounted (ignoring)\");\n      return;\n    }\n\n    const { clientWidth, clientHeight } = this.state.canvas;\n    const updatedViewport = computeCameraViewport(clientWidth, clientHeight);\n    updateOrthoCamera(this.state.camera, updatedViewport);\n    this.state.renderer.setSize(\n      clientWidth,\n      clientHeight,\n      /* updateStyle */ false\n    );\n    this.invalidateIfPaused();\n  }\n}\n\nfunction rgbColorToThreeColor(color: RgbColor): ThreeColor {\n  return new ThreeColor(color.red / 255, color.green / 255, color.blue / 255);\n}\n\nfunction vector2LikeToThreeVector2(vector: Vector2Like): Vector2 {\n  if (typeof vector === \"number\") {\n    return new Vector2(vector, vector);\n  } else {\n    return new Vector2(vector[0], vector[1]);\n  }\n}\n\n/**\n * Class to ensure that the render loop is stopped when the renderer becomes\n * unmounted, without introducing data races.\n */\nclass RenderStopWrapper {\n  private rendering = false;\n  private readonly renderCallback: (time: DOMHighResTimeStamp) => void;\n\n  constructor(renderCallback: (time: DOMHighResTimeStamp) => void) {\n    this.renderCallback = renderCallback;\n  }\n\n  public start(): void {\n    this.rendering = true;\n    window.requestAnimationFrame(this.renderAndScheduleNext.bind(this));\n  }\n\n  public stop(): void {\n    this.rendering = false;\n  }\n\n  private renderAndScheduleNext(timestamp: DOMHighResTimeStamp): void {\n    if (this.rendering) {\n      this.renderCallback(timestamp);\n      window.requestAnimationFrame(this.renderAndScheduleNext.bind(this));\n    }\n  }\n}\n","import { OrthographicCamera } from \"three\";\n\nexport type OrthoViewport = {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n  near: number;\n  far: number;\n};\n\nexport function adaptiveZoomOrthoViewport({\n  clientWidth,\n  clientHeight,\n  baseViewport,\n}: {\n  clientWidth: number;\n  clientHeight: number;\n  baseViewport: OrthoViewport;\n}): OrthoViewport {\n  // Make the viewport the same aspect ratio as the screen, without\n  // changing its position relative to its center. The new dimensions must\n  // fit within the base viewport.\n\n  const aspectRatio = clientWidth / clientHeight;\n  const viewportAspectRatio =\n    (baseViewport.right - baseViewport.left) /\n    (baseViewport.top - baseViewport.bottom);\n\n  const newViewport = { ...baseViewport };\n\n  if (aspectRatio < viewportAspectRatio) {\n    // The screen is wider than the viewport, so we need to shrink the\n    // viewport horizontally.\n    const width = baseViewport.top - baseViewport.bottom;\n    newViewport.left = (-width * aspectRatio) / 2;\n    newViewport.right = (width * aspectRatio) / 2;\n  } else {\n    // The screen is taller than the viewport, so we need to shrink the\n    // viewport vertically.\n    const height = baseViewport.right - baseViewport.left;\n    newViewport.top = height / aspectRatio / 2;\n    newViewport.bottom = -height / aspectRatio / 2;\n  }\n\n  return newViewport;\n}\n\nexport function updateOrthoCamera(\n  mutCamera: OrthographicCamera,\n  viewport: OrthoViewport\n): void {\n  mutCamera.left = viewport.left;\n  mutCamera.right = viewport.right;\n  mutCamera.top = viewport.top;\n  mutCamera.bottom = viewport.bottom;\n  mutCamera.near = viewport.near;\n  mutCamera.far = viewport.far;\n  mutCamera.updateProjectionMatrix();\n}\n\nexport function createOrthoCamera(viewport: OrthoViewport): OrthographicCamera {\n  const camera = new OrthographicCamera(\n    viewport.left,\n    viewport.right,\n    viewport.top,\n    viewport.bottom,\n    viewport.near,\n    viewport.far\n  );\n  return camera;\n}\n","export default \"#define GLSLIFY 1\\n// clang-format off\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// clang-format on\\n\\nvec3 blendFunc(vec3 bg, vec3 fg, float alpha) {\\n  return blendNormal(bg, fg, alpha);\\n}\\n\";","export default \"#define GLSLIFY 1\\n// clang-format off\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\n// clang-format on\\n\\nfloat noiseFunc(vec3 v) { return snoise(v); }\\n\";","import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n} from \"react\";\nimport type { RgbColor } from \"polished/lib/types/color\";\nimport isDeepEqual from \"fast-deep-equal\";\nimport type { IUniform } from \"three\";\n\nimport WaveRenderer from \"./WaveRenderer\";\nimport type { Vector2Like } from \"./WaveRenderer\";\nimport { log, logWarn, logError } from \"./log\";\nimport type { NonEmptyArray } from \"../../ts-utils\";\n\nexport type WaveCanvasProps = {\n  /**\n   * An array of colors that will appear as scrolling \"lights\" on the wave.\n   * There must be at least one color.\n   */\n  colors: Readonly<NonEmptyArray<RgbColor>>;\n  /**\n   * Color that will be used as the \"clear color\" for the canvas.\n   */\n  fallbackColor: RgbColor;\n  /**\n   * Called after the canvas has been initialized, before the first frame\n   * is rendered.\n   */\n  onLoad?: () => void;\n  /**\n   * Called at the end of each frame.\n   */\n  onRender?: () => void;\n  /**\n   * The initial time for the wave animation. This can be used to control\n   * the initial frame so that it is reproducible.\n   */\n  timeOffset?: number;\n  /**\n   * The subdivision of the plane geometry. This is a vector so that the\n   * plane can be subdivided differently in the x and y directions.\n   *\n   * Note that the vector passed in is implicitly scaled by the plane's aspect\n   * ratio, might may not be square.\n   */\n  subdivision?: Vector2Like;\n  /**\n   * Whether the animation is paused.\n   */\n  isPaused?: boolean;\n  /**\n   * A custom noise function for the wave deformation and colors. This is a\n   * GLSL snippet that should contain an implementation for the following\n   * interface:\n   *\n   * ```glsl\n   * float noiseFunc(vec3 v);\n   * ```\n   */\n  customNoiseSource?: string;\n  /**\n   * A custom blend function for the light colors. This is a GLSL snippet\n   * that should contain an implementation for the following interface:\n   *\n   * ```glsl\n   * vec3 blendFunc(vec3 bg, vec3 fg, float alpha);\n   * ```\n   */\n  customBlendSource?: string;\n  /**\n   * Custom uniforms available in the shaders.\n   */\n  customUniforms?: Record<string, IUniform>;\n\n  /**\n   * The frequency of the deform noise texture. Higher values increase the\n   * number of peaks and valleys that appear on the plane, and decrease their\n   * x-y size. This is a vector so that the noise can be scaled differently in\n   * the x and y directions.\n   */\n  deformNoiseFrequency?: Vector2Like;\n  /**\n   * The speed of the animation of the deform noise texture. Higher values\n   * result in faster animation.\n   */\n  deformNoiseSpeed?: number;\n  /**\n   * The strength of the deform noise texture. Higher values result in\n   * sharper valleys and peaks.\n   */\n  deformNoiseStrength?: number;\n  /**\n   * The speed of the passive scrolling of the deform noise texture. Higher\n   * values result in faster scrolling. This is a vector so that the noise can\n   * be scrolled at different speeds in the x and y directions.\n   */\n  deformNoiseScrollSpeed?: Vector2Like;\n  /**\n   * The minimum value of the deform noise texture.\n   */\n  deformNoiseClampLow?: number;\n  /**\n   * The maximum value of the deform noise texture.\n   */\n  deformNoiseClampHigh?: number;\n\n  /**\n   * The frequency of the light noise texture. Higher values increase the\n   * number of bright areas that appear on the plane and decrease their size.\n   * This is a vector so that the noise can be scaled differently in the x and\n   * y directions.\n   */\n  lightNoiseFrequency?: Vector2Like;\n  /**\n   * The speed of the animation of the light noise texture. Higher values\n   * result in faster animation.\n   */\n  lightNoiseSpeed?: number;\n  /**\n   * The speed of the passive scrolling of the light noise texture. Higher\n   * values result in faster scrolling. This is a vector so that the noise can\n   * be scrolled at different speeds in the x and y directions.\n   */\n  lightNoiseScrollSpeed?: Vector2Like;\n  /**\n   * The minimum value of the light noise texture.\n   */\n  lightNoiseClampLow?: number;\n  /**\n   * The maximum value of the light noise texture.\n   */\n  lightNoiseClampHigh?: number;\n  /**\n   * The opacity that each light will have when blended together. The last\n   * light will inherently be the strongest, since it is applied last (using a\n   * \"normal\" blend mode).\n   */\n  lightBlendStrength?: number;\n  /**\n   * The offset that each successive light will have on the noise texture.\n   */\n  perLightNoiseOffset?: number;\n\n  className?: string;\n  style?: React.CSSProperties;\n};\n\nexport type WaveCanvasRef = {\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>;\n  rendererRef: React.MutableRefObject<WaveRenderer | null>;\n};\n\n/**\n * Displays an animated wavy background, using a Canvas element to render the\n * background with Three.js/WebGL.\n *\n * All props other than `className` and `style` are safe to change between SSR\n * and client render, since their values are only used in effects.\n */\nconst WaveCanvas = forwardRef<WaveCanvasRef, WaveCanvasProps>(\n  (\n    {\n      colors,\n      fallbackColor,\n      onLoad,\n      onRender,\n      timeOffset,\n      subdivision,\n      isPaused,\n      customNoiseSource,\n      customBlendSource,\n      customUniforms,\n      deformNoiseFrequency,\n      deformNoiseSpeed,\n      deformNoiseStrength,\n      deformNoiseScrollSpeed,\n      deformNoiseClampLow,\n      deformNoiseClampHigh,\n      lightNoiseFrequency,\n      lightNoiseSpeed,\n      lightNoiseScrollSpeed,\n      lightNoiseClampLow,\n      lightNoiseClampHigh,\n      lightBlendStrength,\n      perLightNoiseOffset,\n      className,\n      style,\n    }: WaveCanvasProps,\n    selfRef\n  ): React.ReactElement | null => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n    const rendererRef = useRef<WaveRenderer | null>(null);\n\n    useImperativeHandle(selfRef, () => ({ canvasRef, rendererRef }));\n\n    const skipEffectBeforeInit = (\n      effect: React.EffectCallback\n    ): ReturnType<React.EffectCallback> => {\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      if (rendererRef.current != null) {\n        return effect();\n      }\n    };\n\n    // Prop change effects.\n    //\n    // These need to be ordered before the initialization effect,\n    // since we don't want the prop change effects to run on the initial render\n    // (see `skipEffectBeforeInit` function).\n    useEffectOnDeepUpdate(\n      () => skipEffectBeforeInit(() => rendererRef.current?.setColors(colors)),\n      [colors]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setFallbackColor(fallbackColor)\n        ),\n      [fallbackColor]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setOnLoad(onLoad ?? null)\n        ),\n      [onLoad]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setOnRender(onRender ?? null)\n        ),\n      [onRender]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setTimeOffset(timeOffset ?? null)\n        ),\n      [timeOffset]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setSubdivision(subdivision ?? null)\n        ),\n      [subdivision]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setIsPaused(isPaused ?? null)\n        ),\n      [isPaused]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setNoiseSource(customNoiseSource ?? null)\n        ),\n      [customNoiseSource]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setBlendSource(customBlendSource ?? null)\n        ),\n      [customBlendSource]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setExtraUniforms(customUniforms ?? null)\n        ),\n      [customUniforms]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseFrequency(\n            deformNoiseFrequency ?? null\n          )\n        ),\n      [deformNoiseFrequency]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseSpeed(deformNoiseSpeed ?? null)\n        ),\n      [deformNoiseSpeed]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseStrength(\n            deformNoiseStrength ?? null\n          )\n        ),\n      [deformNoiseStrength]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseScrollSpeed(\n            deformNoiseScrollSpeed ?? null\n          )\n        ),\n      [deformNoiseScrollSpeed]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseClampLow(\n            deformNoiseClampLow ?? null\n          )\n        ),\n      [deformNoiseClampLow]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setDeformNoiseClampHigh(\n            deformNoiseClampHigh ?? null\n          )\n        ),\n      [deformNoiseClampHigh]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightNoiseFrequency(\n            lightNoiseFrequency ?? null\n          )\n        ),\n      [lightNoiseFrequency]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightNoiseSpeed(lightNoiseSpeed ?? null)\n        ),\n      [lightNoiseSpeed]\n    );\n    useEffectOnDeepUpdate(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightNoiseScrollSpeed(\n            lightNoiseScrollSpeed ?? null\n          )\n        ),\n      [lightNoiseScrollSpeed]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightNoiseClampLow(lightNoiseClampLow ?? null)\n        ),\n      [lightNoiseClampLow]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightNoiseClampHigh(\n            lightNoiseClampHigh ?? null\n          )\n        ),\n      [lightNoiseClampHigh]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setLightBlendStrength(lightBlendStrength ?? null)\n        ),\n      [lightBlendStrength]\n    );\n    useEffect(\n      () =>\n        skipEffectBeforeInit(() =>\n          rendererRef.current?.setPerLightNoiseOffset(\n            perLightNoiseOffset ?? null\n          )\n        ),\n      [perLightNoiseOffset]\n    );\n\n    // Initialization effect\n    useEffect(() => {\n      if (canvasRef.current === null) {\n        logError(\"WaveCanvas\", \"canvasRef.current is null in init\");\n        return;\n      }\n\n      const renderer = new WaveRenderer();\n      renderer.setOnLoad(onLoad ?? null);\n      renderer.setOnRender(onRender ?? null);\n      renderer.setColors(colors);\n      renderer.setFallbackColor(fallbackColor);\n      renderer.setTimeOffset(timeOffset ?? null);\n      renderer.setSubdivision(subdivision ?? null);\n      renderer.setIsPaused(isPaused ?? null);\n      renderer.setNoiseSource(customNoiseSource ?? null);\n      renderer.setBlendSource(customBlendSource ?? null);\n      renderer.setExtraUniforms(customUniforms ?? null);\n      renderer.setDeformNoiseFrequency(deformNoiseFrequency ?? null);\n      renderer.setDeformNoiseSpeed(deformNoiseSpeed ?? null);\n      renderer.setDeformNoiseStrength(deformNoiseStrength ?? null);\n      renderer.setDeformNoiseScrollSpeed(deformNoiseScrollSpeed ?? null);\n      renderer.setDeformNoiseClampLow(deformNoiseClampLow ?? null);\n      renderer.setDeformNoiseClampHigh(deformNoiseClampHigh ?? null);\n      renderer.setLightNoiseFrequency(lightNoiseFrequency ?? null);\n      renderer.setLightNoiseSpeed(lightNoiseSpeed ?? null);\n      renderer.setLightNoiseScrollSpeed(lightNoiseScrollSpeed ?? null);\n      renderer.setLightNoiseClampLow(lightNoiseClampLow ?? null);\n      renderer.setLightNoiseClampHigh(lightNoiseClampHigh ?? null);\n      renderer.setLightBlendStrength(lightBlendStrength ?? null);\n      renderer.setPerLightNoiseOffset(perLightNoiseOffset ?? null);\n      rendererRef.current = renderer;\n\n      // Make the canvas initialization low-priority, if possible:\n      const deferredInit = (): void => {\n        if (rendererRef.current === null) {\n          // Possible if the component unmounted before this callback ran.\n          logWarn(\n            \"WaveCanvas\",\n            \"rendererRef.current was null in deferred init\"\n          );\n          return;\n        } else if (canvasRef.current === null) {\n          logWarn(\"WaveCanvas\", \"canvasRef.current was null in deferred init\");\n          return;\n        }\n\n        log(\"WaveCanvas\", \"Mounting renderer\");\n        rendererRef.current.mount({ canvas: canvasRef.current });\n      };\n      if (\"requestIdleCallback\" in window) {\n        window.requestIdleCallback(deferredInit, { timeout: 1000 });\n      } else {\n        (window as Window).setTimeout(deferredInit, 200);\n      }\n\n      return (): void => {\n        if (rendererRef.current === null) {\n          logWarn(\"WaveCanvas\", \"rendererRef.current was null in unmount\");\n          return;\n        }\n\n        log(\"WaveCanvas\", \"Unmounting renderer\");\n        rendererRef.current.unmount();\n        rendererRef.current = null;\n      };\n\n      // This hook should only run once upon mounting, with the initial props:\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    return <canvas ref={canvasRef} className={className} style={style} />;\n  }\n);\n\nexport default WaveCanvas;\n\n/**\n * Run an effect only when the dependencies change deeply.\n */\nfunction useEffectOnDeepUpdate(\n  effect: React.EffectCallback,\n  dependencies: React.DependencyList\n): void {\n  const previousValues = useRef(dependencies);\n  useEffect(() => {\n    const currentValues = dependencies;\n    if (!isDeepEqual(previousValues.current, currentValues)) {\n      previousValues.current = currentValues;\n      return effect();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n","import WaveCanvas from \"./WaveCanvas\";\n\nexport default WaveCanvas;\n","import { Color } from \"three\";\n\nimport vertexShader from \"./main.vert\";\nimport fragmentShader from \"./main.frag\";\n\nexport const MAX_LIGHTS = 8;\nexport type LightStruct = {\n  count: number;\n  colors: Array<Color>;\n};\n\nexport function makeVertexShader({\n  noiseSource,\n  blendSource,\n}: {\n  noiseSource: string;\n  blendSource: string;\n}): string {\n  return `\n    ${noiseSource}\n    ${blendSource}\n    ${vertexShader}\n  `;\n}\n\nexport function makeFragmentShader(): string {\n  return fragmentShader;\n}\n","export default \"#define GLSLIFY 1\\nvarying vec3 outColor;\\n\\nvoid main() {\\n  gl_FragColor = vec4(outColor, 1.0);\\n}\\n\";"],"names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","doesWindowConsoleExist","window","console","log","subsystem","message","logWarn","warn","logError","error","PLANE_ASPECT","Vector2","PLANE_SCALE","CAMERA_BASE_VIEWPORT","left","right","top","bottom","near","far","computeCameraViewport","clientWidth","clientHeight","baseViewport","aspectRatio","viewportAspectRatio","newViewport","width","height","adaptiveZoomOrthoViewport","WaveRenderer","onLoadCallback","onRenderCallback","colors","DEFAULT_WAVE_COLOR","fallbackColor","timeOffset","DEFAULT_INITIAL_TIME","subdivision","DEFAULT_SUBDIVISION","startPaused","startAtTime","blendSource","DEFAULT_BLEND_SOURCE","noiseSource","DEFAULT_NOISE_SOURCE","extraUniforms","deformNoiseFrequency","DEFAULT_DEFORM_NOISE_FREQUENCY","deformNoiseSpeed","DEFAULT_DEFORM_NOISE_SPEED","deformNoiseStrength","DEFAULT_DEFORM_NOISE_STRENGTH","deformNoiseScrollSpeed","DEFAULT_DEFORM_NOISE_SCROLL_SPEED","deformNoiseClampLow","DEFAULT_DEFORM_NOISE_CLAMP_LOW","deformNoiseClampHigh","DEFAULT_DEFORM_NOISE_CLAMP_HIGH","lightNoiseFrequency","DEFAULT_LIGHT_NOISE_FREQUENCY","lightNoiseSpeed","DEFAULT_LIGHT_NOISE_SPEED","lightNoiseScrollSpeed","DEFAULT_LIGHT_NOISE_SCROLL_SPEED","lightNoiseClampLow","DEFAULT_LIGHT_NOISE_CLAMP_LOW","lightNoiseClampHigh","DEFAULT_LIGHT_NOISE_CLAMP_HIGH","lightBlendStrength","DEFAULT_LIGHT_BLEND_STRENGTH","perLightNoiseOffset","DEFAULT_PER_LIGHT_NOISE_OFFSET","state","type","_proto","setOnLoad","callback","this","setOnRender","setColors","colorsCopy","slice","MAX_LIGHTS","material","uniforms","inLights","value","getLightsUniformValue","invalidateIfPaused","setFallbackColor","color","renderer","setClearColor","rgbColorToThreeColor","setTimeOffset","time","setSubdivision","plane","geometry","dispose","createPlaneGeometry","setIsPaused","isPaused","playbackState","now","performance","pauseTime","startTimestamp","forceRerenderNextFrame","newStartTimestamp","frameCount","setNoiseSource","vertexShader","makeVertexShader","needsUpdate","setBlendSource","setExtraUniforms","newUniforms","uniformKeysBefore","Set","xs","ys","size","_toConsumableArray","every","x","has","setEquality","entries","forEach","_ref","assign","setDeformNoiseFrequency","frequency","inDeformNoiseFrequency","getDeformNoiseFrequency","setDeformNoiseSpeed","speed","inDeformNoiseSpeed","getDeformNoiseSpeed","setDeformNoiseStrength","strength","inDeformNoiseStrength","getDeformNoiseStrength","setDeformNoiseScrollSpeed","scrollSpeed","inDeformNoiseScrollSpeed","getDeformNoiseScrollSpeed","setDeformNoiseClampLow","clampLow","inDeformNoiseClampLow","setDeformNoiseClampHigh","clampHigh","inDeformNoiseClampHigh","setLightNoiseFrequency","inLightNoiseFrequency","getLightNoiseFrequency","setLightNoiseSpeed","inLightNoiseSpeed","getLightNoiseSpeed","setLightNoiseScrollSpeed","inLightNoiseScrollSpeed","getLightNoiseScrollSpeed","setLightNoiseClampLow","inLightNoiseClampLow","setLightNoiseClampHigh","inLightNoiseClampHigh","setLightBlendStrength","inLightBlendStrength","setPerLightNoiseOffset","offset","inPerLightNoiseOffset","mount","canvas","scene","Scene","initialViewport","camera","viewport","OrthographicCamera","name","add","WebGLRenderer","antialias","setSize","setPixelRatio","devicePixelRatio","setupScene","boundOnResizeWindow","onResizeWindow","bind","addEventListener","renderStopWrapper","RenderStopWrapper","render","start","unmount","removeEventListener","stop","restartAnimation","exportImage","mimeType","inTime","getTime","toDataURL","createMaterial","ShaderMaterial","fragmentShader","makeFragmentShader","Mesh","rotation","Math","PI","y","baseSubdivisions","vector2LikeToThreeVector2","subdivisions","ceil","PlaneGeometry","count","map","concat","fill","red","green","blue","vec","multiplyScalar","timestamp","Error","atTimestamp","seekToTime","updatedViewport","mutCamera","updateProjectionMatrix","ThreeColor","vector","renderCallback","rendering","requestAnimationFrame","renderAndScheduleNext","useEffectOnDeepUpdate","effect","dependencies","previousValues","useRef","useEffect","currentValues","isDeepEqual","current","forwardRef","selfRef","onLoad","onRender","customNoiseSource","customBlendSource","customUniforms","className","style","canvasRef","rendererRef","useImperativeHandle","skipEffectBeforeInit","_rendererRef$current","_rendererRef$current2","_rendererRef$current3","_rendererRef$current4","_rendererRef$current5","_rendererRef$current6","_rendererRef$current7","_rendererRef$current8","_rendererRef$current9","_rendererRef$current10","_rendererRef$current11","_rendererRef$current12","_rendererRef$current13","_rendererRef$current14","_rendererRef$current15","_rendererRef$current16","_rendererRef$current17","_rendererRef$current18","_rendererRef$current19","_rendererRef$current20","_rendererRef$current21","_rendererRef$current22","_rendererRef$current23","deferredInit","requestIdleCallback","timeout","setTimeout","___EmotionJSX","ref"],"sourceRoot":""}