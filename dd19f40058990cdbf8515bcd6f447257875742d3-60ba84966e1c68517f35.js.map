{"version":3,"file":"dd19f40058990cdbf8515bcd6f447257875742d3-60ba84966e1c68517f35.js","mappings":"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","sources":["webpack://jazevedo.me/./src/components/HeroBackground.tsx","webpack://jazevedo.me/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js"],"sourcesContent":["import React, {\n  Suspense,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport styled from \"@emotion/styled\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport { parseToRgb, rgba } from \"polished\";\nimport { ClassNames } from \"@emotion/react\";\nimport type { ClassNamesContent } from \"@emotion/react\";\nimport type { RgbColor } from \"polished/lib/types/color\";\n\nimport {\n  hybridColor,\n  ColorMode,\n  mode,\n  HeroBackgroundColors as HeroBackgroundColorStrings,\n} from \"../theme/color\";\nimport {\n  useColorMode,\n  useGlobalDebugHandle,\n  useInitialRender,\n  useMediaQuery,\n} from \"../hooks\";\nimport type { NonEmptyArray, TupleVector2 } from \"../ts-utils\";\n// Must only `import type` from WaveCanvas, since it should be bundle-split:\nimport type { WaveCanvasRef } from \"./WaveCanvas/WaveCanvas\";\n\nfunction enumKeys<O extends object, K extends keyof O = keyof O>(obj: O): K[] {\n  return Object.keys(obj).filter((k) => Number.isNaN(+k)) as K[];\n}\n\nconst HeroBackgroundColorObjects: {\n  [k in ColorMode]: NonEmptyArray<RgbColor>;\n} = Object.fromEntries(\n  Object.entries(\n    // Assert that the constant is correct so that the output of the\n    // transformation is valid.\n    HeroBackgroundColorStrings satisfies {\n      [k in ColorMode]: Readonly<NonEmptyArray<string>>;\n    }\n  ).map(([k, v]) => [k, v.map((c) => parseToRgb(c))])\n) as { [k in ColorMode]: NonEmptyArray<RgbColor> };\n\nconst Styled = {\n  HeroLayout: styled.div`\n    display: grid;\n    height: min(100%, 100vh);\n    width: 100%;\n    z-index: -1;\n    user-select: none;\n\n    .dark-fallback,\n    .light-fallback {\n      max-height: 100vh;\n    }\n\n    ${mode(ColorMode.Light)} {\n      .dark-fallback {\n        display: none;\n      }\n    }\n\n    ${mode(ColorMode.Dark)} {\n      .light-fallback {\n        display: none;\n      }\n    }\n\n    /* When forced-colors are enabled, hide the background */\n    @media (forced-colors: active) {\n      .dark-fallback,\n      .light-fallback {\n        display: none;\n      }\n    }\n  `,\n  makeWaveCanvasClassName: (css: ClassNamesContent[\"css\"]): string => css`\n    opacity: 0;\n    transition: opacity 1s linear;\n    grid-area: 1/1;\n    height: 100%;\n    width: 100%;\n    z-index: 1;\n    max-height: 100vh;\n    &.wave-canvas-loaded {\n      opacity: 1;\n    }\n\n    /* When forced-colors or prefers-reduced-motion are enabled, hide the\n    canvas. This is also done in script, but duplicate it here. */\n    @media (forced-colors: active) {\n      display: none;\n    }\n    @media (prefers-reduced-motion: reduce) {\n      display: none;\n    }\n  `,\n  HeroMask: styled.div`\n    height: 100%;\n\n    /* Construct the wave-like mask and full-screen color overlay,\n    using partially-faded background color values for all color modes.\n    Previously, this used a PNG mask to accomplish the wave shape,\n    but having it all in CSS reduces the data transferred\n    and makes it a lot easier to change the colors */\n    ${enumKeys(ColorMode)\n      .map(\n        (key) => `\n          ${mode(ColorMode[key])} {\n            background-color:\n              ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.3)};\n            background-image: linear-gradient(\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)} 30%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 1)} 95%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 1)}\n              ),\n              radial-gradient(\n                circle 40vw at right 20% bottom 0%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.8)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              ),\n              radial-gradient(\n                circle 40vw at right 20% bottom 30%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.8)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              ),\n              radial-gradient(\n                circle 40vw at right 20% bottom 40%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.8)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              ),\n              radial-gradient(\n                circle 35vw at left -5% bottom 0%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.8)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              ),\n              radial-gradient(\n                circle 35vw at left -5% bottom 5%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.8)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              ),\n              radial-gradient(\n                circle 35vw at left 50% bottom 0%,\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0.5)},\n                ${rgba(hybridColor(\"bg\", ColorMode[key]), 0)}\n              );\n          }`\n      )\n      .join(\"\\n\")}\n\n    /* When forced-colors are enabled, hide the background */\n    @media (forced-colors: active) {\n      display: none;\n    }\n  `,\n};\n\nexport type HeroBackgroundProps = {\n  className?: string;\n  style?: React.CSSProperties;\n};\n\n/**\n * Displays an animated wavy background with a gradient mask on top of it\n * to fade into the normal site background at the bottom.\n *\n * While loading, the background uses blurred Gatsby images as a placeholder,\n * and then smoothly fades the animated canvas in once it's ready.\n *\n * ### Steps for regenerating the background fallback images:\n * 1. Open the homepage of the site.\n * 2. Open Chrome devtools, and use the device toolbar to manually set the\n *    device resolution to 3840x3840. Ensure the device pixel ratio is set to 1.\n * 3. In the console, run:\n *    ```js\n *    window.debug.takeHeroBackgroundFallbacks();\n *    ```\n */\nexport default function HeroBackground({\n  className,\n  style,\n}: HeroBackgroundProps): React.ReactElement {\n  // Disable the animated gradient if the agent prefers reduced motion,\n  // or if a forced color/high contrast mode is enabled.\n  //\n  // Additionally, only render the canvas on the client.\n  const initialRender = useInitialRender();\n  const reducedMotion = useMediaQuery(\"(prefers-reduced-motion: reduce)\");\n  const usingForcedColor = useMediaQuery(\"(forced-colors: active)\");\n  const renderWaveCanvas =\n    !initialRender && !usingForcedColor && !reducedMotion;\n\n  return (\n    <Styled.HeroLayout className={className} style={style}>\n      <StaticImage\n        className=\"dark-fallback\"\n        style={{\n          gridArea: \"1/1\",\n          zIndex: 0,\n          userSelect: \"none\",\n        }}\n        layout=\"fullWidth\"\n        alt=\"\"\n        src=\"../images/hero/fallback.dark.png\"\n        placeholder=\"blurred\"\n        formats={[\"auto\", \"webp\", \"avif\"]}\n        quality={60}\n        draggable={false}\n      />\n      <StaticImage\n        className=\"light-fallback\"\n        style={{\n          gridArea: \"1/1\",\n          zIndex: 0,\n          userSelect: \"none\",\n        }}\n        layout=\"fullWidth\"\n        alt=\"\"\n        src=\"../images/hero/fallback.light.png\"\n        placeholder=\"blurred\"\n        formats={[\"auto\", \"webp\", \"avif\"]}\n        quality={60}\n        draggable={false}\n      />\n      {renderWaveCanvas && <WaveCanvasLazyLoader />}\n      <Styled.HeroMask style={{ gridArea: \"1/1\", zIndex: 2 }} />\n    </Styled.HeroLayout>\n  );\n}\n\nasync function requestLowPriority(): Promise<void> {\n  if (\"requestIdleCallback\" in window) {\n    return new Promise((resolve) => {\n      window.requestIdleCallback(() => resolve(), { timeout: 2000 });\n    });\n  } else {\n    return new Promise((resolve) => {\n      setTimeout(() => resolve(), 500);\n    });\n  }\n}\n\nconst LazyWaveCanvas = React.lazy(async () => {\n  // Load the WaveCanvas component asynchronously, at a low priority.\n  await requestLowPriority();\n  const WaveCanvas = await import(\"./WaveCanvas\");\n  return WaveCanvas;\n});\n\n/**\n * Client-side only component that loads the WaveCanvas component.\n */\nfunction WaveCanvasLazyLoader(): React.ReactElement {\n  const colorMode = useColorMode();\n  const [isLoaded, setIsLoaded] = useState(false);\n  const onLoad = useCallback(() => {\n    setIsLoaded(true);\n  }, []);\n  const canvasRef = useRef<WaveCanvasRef | null>(null);\n\n  // Augment the global scope's `debug` object with a  command to take a\n  // screenshot of the canvas, at the beginning of the animation.\n  useGlobalDebugHandle(\n    {\n      takeHeroBackgroundFallbacks: (): void => {\n        window.console.log(\"[HeroBackground] Taking screenshots...\");\n        const rendererRef = canvasRef.current?.rendererRef.current;\n        if (rendererRef == null) {\n          window.console.error(\n            \"[HeroBackground] Failed to make fallback images: no renderer ref\"\n          );\n          return;\n        }\n\n        Object.values(ColorMode).forEach((m) => {\n          rendererRef.seekToTime(0);\n          rendererRef.setFallbackColor(HeroBackgroundColorObjects[m][0]);\n          rendererRef.setColors(HeroBackgroundColorObjects[m]);\n          const imageData = rendererRef.exportImage(\"image/png\") ?? \"\";\n          if (imageData === \"\") {\n            window.console.error(\"[HeroBackground] Failed to take screenshot\");\n            return;\n          }\n\n          const fakeDownloadLink = document.createElement(\"a\");\n          fakeDownloadLink.download = `fallback.${m}.png`;\n          fakeDownloadLink.href = imageData;\n          fakeDownloadLink.click();\n          window.console.log(`[HeroBackground] Took screenshot for ${m}`);\n        });\n\n        window.console.log(\"[HeroBackground] Success\");\n      },\n    },\n    []\n  );\n\n  // When the canvas first loads, slowly ramp up the animation speed.\n  // This has to be done in a bit of a hack, since each frame of the animation\n  // is a function of both the current speed and the time elapsed since the\n  // start of the animation (instead of just the time since the start).\n  //\n  // Instead, we need to manually adjust both the time offset and current time\n  // of the animation in a way that preserves the current animation state\n  // across speed changes:\n\n  const baseTimeOffset = 32;\n  const baseDeformNoiseSpeed = 3;\n  const baseDeformNoiseScrollSpeed = [1.5, 0.5] as const;\n  const baseLightNoiseSpeed = 3;\n  const baseLightNoiseScrollSpeed = [2.5, 1] as const;\n\n  const speedRamp = [0.001, 0.2, 0.4, 0.6, 0.8, 1] as const;\n  const rampDelayMs = 1000;\n  const [speedRampIndex, setSpeedRampIndex] = useState<number>(0);\n\n  const getTimeOffset = (index: number): number =>\n    baseTimeOffset / speedRamp[index];\n  const getDeformNoiseSpeed = (index: number): number =>\n    speedRamp[index] * baseDeformNoiseSpeed;\n  const getDeformNoiseScrollSpeed = (index: number): TupleVector2 =>\n    baseDeformNoiseScrollSpeed.map(\n      (v) => v * speedRamp[index]\n    ) as unknown as TupleVector2;\n  const getLightNoiseSpeed = (index: number): number =>\n    speedRamp[index] * baseLightNoiseSpeed;\n  const getLightNoiseScrollSpeed = (index: number): TupleVector2 =>\n    baseLightNoiseScrollSpeed.map(\n      (v) => v * speedRamp[index]\n    ) as unknown as TupleVector2;\n\n  useEffect((): (() => void) | void => {\n    if (isLoaded && speedRampIndex < speedRamp.length - 1) {\n      const timeout = setTimeout(() => {\n        const rendererRef = canvasRef.current?.rendererRef.current;\n        if (rendererRef != null) {\n          const oldSpeedIndex = speedRampIndex;\n          const newSpeedIndex = speedRampIndex + 1;\n\n          // Instantly update the animation's speed, without waiting for a React\n          // render cycle.\n\n          // Additionally, correct the time of the animation to account for the\n          // speed change.\n          //\n          // This needs to preserve the following equation:\n          // (oldTime + oldTimeOffset) * oldSpeed = (newTime + newTimeOffset) * newSpeed\n          //\n          // Or, equivalently:\n          // oldTime * oldSpeed = newTime * newSpeed\n          const oldSpeed = speedRamp[oldSpeedIndex];\n          const newSpeed = speedRamp[newSpeedIndex];\n          const oldTime = rendererRef.getTime();\n          const newTime = (oldTime * oldSpeed) / newSpeed;\n          rendererRef.seekToTime(newTime);\n\n          rendererRef.setTimeOffset(getTimeOffset(newSpeedIndex));\n          rendererRef.setDeformNoiseSpeed(getDeformNoiseSpeed(newSpeedIndex));\n          rendererRef.setDeformNoiseScrollSpeed(\n            getDeformNoiseScrollSpeed(newSpeedIndex)\n          );\n          rendererRef.setLightNoiseSpeed(getLightNoiseSpeed(newSpeedIndex));\n          rendererRef.setLightNoiseScrollSpeed(\n            getLightNoiseScrollSpeed(newSpeedIndex)\n          );\n\n          // Update the React state to trigger a re-render and scheduling of the\n          // next speed ramp effect.\n          setSpeedRampIndex(newSpeedIndex);\n        }\n      }, rampDelayMs);\n      return () => clearTimeout(timeout);\n    }\n    // `speedRamp` and `getXXX` are constants, so we can safely disable the\n    // exhaustive-deps rule.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [speedRampIndex, isLoaded]);\n\n  return (\n    <ClassNames>\n      {({ css, cx }): React.ReactElement => (\n        <Suspense fallback={null}>\n          <LazyWaveCanvas\n            ref={canvasRef}\n            colors={HeroBackgroundColorObjects[colorMode]}\n            fallbackColor={HeroBackgroundColorObjects[colorMode][0]}\n            className={cx(Styled.makeWaveCanvasClassName(css), {\n              \"wave-canvas-loaded\": isLoaded,\n            })}\n            onLoad={onLoad}\n            timeOffset={getTimeOffset(speedRampIndex)}\n            deformNoiseSpeed={getDeformNoiseSpeed(speedRampIndex)}\n            deformNoiseScrollSpeed={getDeformNoiseScrollSpeed(speedRampIndex)}\n            lightNoiseSpeed={getLightNoiseSpeed(speedRampIndex)}\n            lightNoiseScrollSpeed={getLightNoiseScrollSpeed(speedRampIndex)}\n            subdivision={72}\n            deformNoiseFrequency={[2, 1.5]}\n            deformNoiseStrength={5}\n            deformNoiseClampLow={0}\n            deformNoiseClampHigh={1}\n            lightNoiseFrequency={1.25}\n            lightNoiseClampLow={-0.3}\n            lightNoiseClampHigh={1}\n            lightBlendStrength={1}\n            perLightNoiseOffset={0.2}\n          />\n        </Suspense>\n      )}\n    </ClassNames>\n  );\n}\n","export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}"],"names":["HeroBackgroundColorObjects","Object","fromEntries","entries","HeroBackgroundColorStrings","map","_ref","k","v","c","parseToRgb","Styled","HeroLayout","mode","ColorMode","makeWaveCanvasClassName","css","strings","raw","slice","HeroMask","obj","keys","filter","Number","isNaN","key","rgba","hybridColor","join","HeroBackground","className","style","initialRender","useInitialRender","reducedMotion","useMediaQuery","usingForcedColor","renderWaveCanvas","___EmotionJSX","StaticImage","gridArea","zIndex","userSelect","layout","alt","src","placeholder","formats","quality","draggable","WaveCanvasLazyLoader","LazyWaveCanvas","React","async","window","Promise","resolve","requestIdleCallback","timeout","setTimeout","requestLowPriority","colorMode","useColorMode","isLoaded","setIsLoaded","useState","onLoad","useCallback","canvasRef","useRef","useGlobalDebugHandle","takeHeroBackgroundFallbacks","console","log","rendererRef","current","_canvasRef$current","values","forEach","m","seekToTime","setFallbackColor","setColors","imageData","exportImage","error","fakeDownloadLink","document","createElement","download","href","click","baseDeformNoiseScrollSpeed","baseLightNoiseScrollSpeed","speedRamp","speedRampIndex","setSpeedRampIndex","getTimeOffset","index","getDeformNoiseSpeed","getDeformNoiseScrollSpeed","getLightNoiseSpeed","getLightNoiseScrollSpeed","useEffect","length","_canvasRef$current2","newSpeedIndex","oldSpeed","newSpeed","newTime","getTime","setTimeOffset","setDeformNoiseSpeed","setDeformNoiseScrollSpeed","setLightNoiseSpeed","setLightNoiseScrollSpeed","clearTimeout","ClassNames","_ref3","cx","Suspense","fallback","ref","colors","fallbackColor","timeOffset","deformNoiseSpeed","deformNoiseScrollSpeed","lightNoiseSpeed","lightNoiseScrollSpeed","subdivision","deformNoiseFrequency","deformNoiseStrength","deformNoiseClampLow","deformNoiseClampHigh","lightNoiseFrequency","lightNoiseClampLow","lightNoiseClampHigh","lightBlendStrength","perLightNoiseOffset"],"sourceRoot":""}